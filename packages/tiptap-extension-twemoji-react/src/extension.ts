import { createRef } from "react";

// UTILITIES
import { getEmojiSprite, getAttributes } from "@/lib/emoji-utils";

// ASSETS
import emojisSubstringIndexes from "@/assets/emoji-substring-index.json";
import emojiSprite from "../../../assets/emoji-sprite.webp";

// DATA
import emojis from "@/data/emoji-sprite-map";

// PLUGINS
import { InputPlugin } from "@/plugins/input-plugin";
import { EmojiCopyPlugin } from "@/plugins/copy-plugin";
import { EmojiPastePlugin } from "@/plugins/paste-plugin";
import { EmojiFallbackCleanupPlugin } from "@/plugins/emoji-fallback-cleanup-plugin";
import { isCustomEmoji, isEmoji } from "@/lib/emoji-grid-utils";

// TYPES ONLY
import type { CommandProps, Editor, Range } from "@tiptap/core";
import type { SuggestionProps as BaseSuggestionProps } from "@tiptap/suggestion";
import type { Emoji } from "@/data/emoji-sprite-map";
import type { MentionNodeAttrs } from "@tiptap/extension-mention";
import type {
  ComponentEmojiMentionProps,
  CustomEmoji,
  SelectEmojiFunc,
  EmojiListRef,
  StoredEmoji,
  ExtensionHeaderOptions,
  ExtensionCustomEmojiOptions,
  ExtensionNavOptions,
  ExtensionGridOptions,
  SuggestionItems,
} from "@/types";

// TIPTAP
import Mention from "@tiptap/extension-mention";
import Suggestion from "@tiptap/suggestion";
import { ReactRenderer } from "@tiptap/react";
import { mergeAttributes } from "@tiptap/core";

// COMPONENTS & CONFIG
import {
  destroyPopoverComponent,
  attachAutoUpdate,
  attachIntersectionObserver,
  attachPointerDownListener,
} from "@/components/popover/config";
import EmojiGrid from "@/components/emoji-grid/grid/Grid";

// CONSTANTS
import {
  CUSTOM_EMOJI_CLASS_NAME,
  DEFAULT_ACCEPT,
  DEFAULT_CELL_SIZE,
  DEFAULT_MAX_SIZE,
  DEFAULT_MIN_CELLS_TO_HIDE_NAV,
  DEFAULT_ON_ERROR,
  DEFAULT_ON_SUCCESS,
  DEFAULT_UPLOAD,
  DEFAULT_VISIBLE_ROWS,
  EMOJI_CLASS_NAME,
  EXTENSION_NAME,
  LOCAL_STORAGE_RECENT_EMOJIS_KEY,
} from "@/constants";

export interface MySuggestionProps<TItems = any, TSelected = any>
  extends Omit<BaseSuggestionProps<any, TSelected>, "items"> {
  items: TItems;
}

declare module "@tiptap/core" {
  interface Commands {
    [EXTENSION_NAME]: {
      insertEmoji: (
        emoji: Emoji | CustomEmoji,
        range: Range
      ) => (props: CommandProps) => boolean;
      updateCustomEmojis: (
        emojis: CustomEmoji[]
      ) => (props: CommandProps) => boolean;
      updateRecentEmojis: (
        emojis: StoredEmoji[]
      ) => (props: CommandProps) => boolean;
    };
  }

  interface Storage {
    [EXTENSION_NAME]?: {
      query: EmojiExtensionStorage["query"];
      customEmojis?: EmojiExtensionStorage["customEmojis"];
      recentEmojis?: EmojiExtensionStorage["recentEmojis"];
    };
  }
}

export interface EmojiExtensionStorage {
  recentEmojis: StoredEmoji[];
  customEmojis: CustomEmoji[];
  query: string;
}

type COMPONENT_PROPS = Omit<
  ComponentEmojiMentionProps,
  "focusImmediately" | "closeAfterDelete" | "onDelete" | "setQuery"
>;

let component: ReactRenderer<EmojiListRef, COMPONENT_PROPS> | null = null;

type TwemojiExtensionProps = {
  /**
   * Url for fetch image remotely.
   * @default /assets/emoji-sprite6102d4c8eb22eb1a.webp
   */
  spriteUrl?: string;
  headerOptions?: ExtensionHeaderOptions;
  customEmojiOptions?: ExtensionCustomEmojiOptions;
  navOptions?: ExtensionNavOptions;
  gridOptions?: ExtensionGridOptions;
};

const TwemojiExtension = Mention.extend<
  TwemojiExtensionProps,
  EmojiExtensionStorage
>({
  name: EXTENSION_NAME,

  async onCreate(props) {
    if (typeof document === "undefined") return; // for ssr

    if (document.getElementById("emoji-sprite-style")) return; // to avoid repeating style definitions

    const finalUrl = this.options.spriteUrl ?? emojiSprite; // emojiSprite is the hashed asset path generated by @rollup/plugin-url, in this case emojiSprite is /assets/[name][hash][extname];

    const style = `
    .${EMOJI_CLASS_NAME} {
      background-image: url(${finalUrl}) !important;
      background-repeat: no-repeat !important;
      display: inline-block !important;
      vertical-align: -0.1em !important;
      object-fit: contain !important;
      cursor: text;
      pointer-events: none;
      }
    .${CUSTOM_EMOJI_CLASS_NAME} {
      background-repeat: no-repeat !important;
      display: inline-block !important;
      vertical-align: -0.1em !important;
      object-fit: contain !important;
      width: 1em;
      height: 1em;
      cursor: text;
      pointer-events: none;
    }
    `;

    const sheet = document.createElement("style");
    sheet.id = "emoji-sprite-style";
    sheet.innerHTML = style;
    document.head.appendChild(sheet);

    // RECENTS EMOJIS INITALIZATION
    const KEY =
      this.options.gridOptions?.localStorageRecentEmojisKey ??
      LOCAL_STORAGE_RECENT_EMOJIS_KEY;
    const storedEmojis = localStorage.getItem(KEY);
    const parsed: StoredEmoji[] = storedEmojis ? JSON.parse(storedEmojis) : [];
    props.editor.commands.updateRecentEmojis(parsed);
  },
  addStorage() {
    return {
      query: "",
      customEmojis: [] as CustomEmoji[],
      recentEmojis: [] as StoredEmoji[],
    };
  },
  addOptions() {
    return {
      ...(this.parent?.() ?? ({} as TwemojiExtensionProps)),
      headerOptions: {
        randomButton: undefined,
        skinToneSelect: undefined,
      },
      customEmojiOptions: {
        accept: undefined,
        maxSize: undefined,
        onError: undefined,
        onSuccess: undefined,
        upload: undefined,
      },
      navOptions: {
        minCellsToHideNav: undefined,
      },
      spriteUrl: undefined,
      gridOptions: {
        cellSize: undefined,
        visibleRows: undefined,
      },
    };
  },

  addAttributes() {
    return {
      ...(this.parent?.() ?? {}),
      "data-type": { default: "emoji" },
      src: { default: null },
      alt: { default: null },
      style: { default: null },
      draggable: { default: false },
      contenteditable: { default: false },
      class: { default: null },
    };
  },
  parseHTML() {
    return [
      {
        tag: "img[data-type='emoji']",
        getAttrs: (dom) => {
          return {
            "data-type": dom.getAttribute("data-type"),
            src: dom.getAttribute("src"),
            alt: dom.getAttribute("alt"),
            style: dom.getAttribute("style"),
            draggable: dom.getAttribute("draggable"),
            contenteditable: dom.getAttribute("contenteditable"),
            class: dom.getAttribute("class"),
          };
        },
      },
    ];
  },
  renderHTML({ node }) {
    return ["img", mergeAttributes(node.attrs)];
  },
  addCommands() {
    return {
      updateCustomEmojis:
        (emojis: CustomEmoji[]) =>
        ({ editor }) => {
          if (editor.storage[EXTENSION_NAME]) {
            editor.storage[EXTENSION_NAME].customEmojis = emojis;
          }

          if (component) {
            const lowerQuery =
              component.props?.query?.toLowerCase().trim() ?? "";

            const filteredCustomEmojis = emojis.filter(({ label }) =>
              label.includes(lowerQuery)
            );

            component.updateProps({ filteredCustomEmojis });
          }

          return true;
        },
      updateRecentEmojis:
        (emojis: StoredEmoji[]) =>
        ({ editor }) => {
          if (editor.storage[EXTENSION_NAME]) {
            editor.storage[EXTENSION_NAME].recentEmojis = emojis;
          }
          return true;
        },
      insertEmoji:
        (data, { from, to }) =>
        ({ editor }) => {
          let attrs: {
            src: string;
            alt: string;
            draggable: boolean;
            class: string;
            style?: string | React.CSSProperties;
          };

          if (isEmoji(data)) {
            const { style, ...attributes } = getAttributes({
              data,
              styleOption: { type: "string" },
            }) as {
              [x: string]: string | boolean;
              src: string;
              alt: string;
              draggable: boolean;
              class: string;
              style: string;
            };

            attrs = {
              ...attributes,
              style: `${style} cursor: text;`,
            };
          } else if (isCustomEmoji(data)) {
            attrs = {
              alt: data.label,
              src: data.url,
              draggable: false,
              class: CUSTOM_EMOJI_CLASS_NAME,
            };
          } else {
            return false;
          }

          return commands.insertContentAt({ from, to }, [
            { type: EXTENSION_NAME, attrs },
            { type: "text", text: " " },
          ]);
        },
    };
  },
  addProseMirrorPlugins() {
    const storage = this.storage;

    return [
      Suggestion({
        editor: this.editor,
        char: ":",
        allow: ({ state, range }) => {
          const triggerText = state.doc.textBetween(
            range.from,
            range.to,
            undefined,
            "\ufffc"
          );

          // 1. Check minimum triggerText length (e.g. ":a" = 2)
          if (triggerText.length < 2) return false;

          const $pos = state.doc.resolve(range.from);

          // 2. Allow if at start of paragraph
          if ($pos.parentOffset === 0) {
            return true;
          }

          // 3. Check character before the ":" trigger
          const indexBefore = range.from - 1;

          if (indexBefore <= 0) {
            // at start of document
            return true;
          }

          const charBefore = state.doc.textBetween(indexBefore, range.from);

          // Allow only if charBefore is space or newline
          if (charBefore === " " || charBefore === "\n") {
            return true;
          }

          // 4. If the node before is a text node with no space, or an inline node like emoji â€“ block it
          return false;
        },
        items: ({ query }) => {
          // update storage query to latest query
          storage.query = query;

          if (query !== "") {
            const lowerQuery = query.toLowerCase().trim();
            if (!lowerQuery) return [];

            const customEmojis = this.storage.customEmojis ?? [];
            const storedEmojis = this.storage.recentEmojis ?? [];

            const filteredCustomEmojis = customEmojis.filter(({ label }) =>
              label.includes(lowerQuery)
            );

            const emojisIndexes = emojisSubstringIndexes as Record<
              string,
              string[]
            >;

            const matchedHexcodes = emojisIndexes[lowerQuery] ?? [];

            const filteredEmojis: Emoji[] = new Array(matchedHexcodes.length);

            for (let i = 0; i < matchedHexcodes.length; i++) {
              filteredEmojis[i] = emojis[matchedHexcodes[i]] as Emoji & {
                hexcode: string;
              };
            }

            let recent: StoredEmoji[] = [];

            const shouldShowRecent =
              storedEmojis.length > 0 && query.length === 1;

            if (shouldShowRecent) {
              recent = storedEmojis.map((emojiData) => {
                const { hexcode, ...rest } = emojiData;

                if (hexcode) {
                  return getEmojiSprite({ hexcode }) as Emoji;
                }

                return rest as CustomEmoji;
              });
            }

            const items: SuggestionItems = [
              filteredEmojis,
              recent,
              filteredCustomEmojis,
            ];

            return items;
          }
          return [[], [], []] as SuggestionItems;
        },
        render: () => {
          // ref for access useImperativeHandle in EmojiList
          const ref = createRef<EmojiListRef>();

          let cleanupFuncArray: ((() => void) | undefined)[] = [];

          const unsubscribePopoverEvents = () => {
            cleanupFuncArray.map((cleanup) => cleanup?.());
            cleanupFuncArray.length = 0; // cleanupFuncArray array to []
          };

          const onCancel = () => {
            storage.query = "";

            unsubscribePopoverEvents();
            destroyPopoverComponent(component);
          };

          const subscribePopoverEvents = (
            decorationNode: Element | null,
            popoverComponent: HTMLDivElement,
            editor: Editor
          ) => {
            cleanupFuncArray.push(
              attachAutoUpdate(decorationNode, popoverComponent, {
                align: "start",
                side: "bottom",
              })
            );

            cleanupFuncArray.push(
              attachIntersectionObserver(decorationNode, onCancel)
            );

            cleanupFuncArray.push(
              attachPointerDownListener(
                [popoverComponent, editor.view.dom],
                onCancel
              )
            );
          };

          return {
            onStart: ({
              editor,
              items,
              range,
              decorationNode,
              query,
            }: MySuggestionProps<SuggestionItems, MentionNodeAttrs>) => {
              onCancel();

              const onSelectEmoji: SelectEmojiFunc = ({
                baseHexcode,
                emoji,
                range,
              }) => {
                if (!range) return;

                const storedEmojis = [...(this.storage.recentEmojis ?? [])];

                const selectedEmoji = isEmoji(emoji)
                  ? {
                      hexcode: baseHexcode,
                    }
                  : {
                      id: emoji.id,
                      label: emoji.label,
                      url: emoji.url,
                    };

                const KEY =
                  this.options.gridOptions?.localStorageRecentEmojisKey ??
                  LOCAL_STORAGE_RECENT_EMOJIS_KEY;

                if (storedEmojis.length > 0) {
                  // check if the emoji is already in the array, if yes then made it first in the array
                  const index = storedEmojis.findIndex((e) =>
                    isEmoji(emoji)
                      ? e.hexcode === baseHexcode
                      : e.id === emoji.id
                  );

                  if (index !== -1) storedEmojis.splice(index, 1);

                  storedEmojis.unshift(selectedEmoji);

                  const item = storedEmojis.slice(0, 24);

                  editor.commands.updateRecentEmojis(item);
                  localStorage.setItem(KEY, JSON.stringify(item));
                } else {
                  editor.commands.updateRecentEmojis([selectedEmoji]);
                  localStorage.setItem(KEY, JSON.stringify([selectedEmoji]));
                }

                // call the command so that it replaces the : with the emoji
                editor.commands.insertEmoji(emoji, range);
              };

              const accept =
                this.options.customEmojiOptions?.accept ?? DEFAULT_ACCEPT;
              const maxSize =
                this.options.customEmojiOptions?.maxSize ?? DEFAULT_MAX_SIZE;
              const upload =
                this.options.customEmojiOptions?.upload ?? DEFAULT_UPLOAD;
              const onError =
                this.options.customEmojiOptions?.onError ?? DEFAULT_ON_ERROR;
              const onSuccess =
                this.options.customEmojiOptions?.onSuccess ??
                DEFAULT_ON_SUCCESS;
              const interceptAddCustomEmojiClick =
                this.options.customEmojiOptions?.interceptAddCustomEmojiClick ??
                false;
              const disabledAddCustomEmoji =
                this.options.customEmojiOptions?.disabledAddCustomEmoji ??
                false;

              const randomButton =
                this.options.headerOptions?.randomButton ?? true;
              const skinToneSelect =
                this.options.headerOptions?.skinToneSelect ?? true;

              const minCellsToHideNav =
                this.options.navOptions?.minCellsToHideNav ??
                DEFAULT_MIN_CELLS_TO_HIDE_NAV;

              const visibleRows =
                this.options.gridOptions?.visibleRows ?? DEFAULT_VISIBLE_ROWS;
              const cellSize =
                this.options.gridOptions?.cellSize ?? DEFAULT_CELL_SIZE;

              const [filteredEmojis, recent, filteredCustomEmojis] = items as [
                Emoji[],
                StoredEmoji[],
                CustomEmoji[],
              ];

              const componentProps: COMPONENT_PROPS = {
                onSelectEmoji,
                onCancel,
                maxSize,
                editor,
                accept,
                range,
                ref,
                upload,
                onError,
                onSuccess,
                randomButton,
                skinToneSelect,
                headerInput: false,
                removeButton: false,
                minCellsToHideNav,
                visibleRows,
                cellSize,
                interceptAddCustomEmojiClick,
                disabledAddCustomEmoji,
                recent,
                filteredEmojis,
                filteredCustomEmojis,
                query,
              };

              component = new ReactRenderer(EmojiGrid, {
                props: componentProps,
                editor,
              });

              const popoverComponent = component.element as HTMLDivElement;

              subscribePopoverEvents(decorationNode, popoverComponent, editor);

              document.body.appendChild(popoverComponent);
            },
            onUpdate({ items, ...props }) {
              if (!component) return;

              const [filteredEmojis, recent, customEmojis] = items as [
                Emoji[],
                StoredEmoji[],
                CustomEmoji[],
              ];

              const lowerQuery = storage.query.toLowerCase().trim();

              const filteredCustomEmojis = customEmojis.filter(({ label }) =>
                label.includes(lowerQuery)
              );

              component.updateProps({
                ...props,
                filteredEmojis,
                recent,
                filteredCustomEmojis,
              });

              const popoverComponent = component.element as HTMLDivElement;

              unsubscribePopoverEvents();

              subscribePopoverEvents(
                props.decorationNode,
                popoverComponent,
                props.editor
              );
            },
            onKeyDown(props) {
              if (props.event.key === "Escape") {
                onCancel();
                return true;
              }

              if (props.event.key === "Tab") {
                const focusableEls =
                  component?.element.querySelectorAll<HTMLElement>(
                    'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
                  ) ?? [];

                const focusables = Array.from(focusableEls).filter(
                  (el) =>
                    !el.hasAttribute("disabled") &&
                    !el.getAttribute("aria-hidden")
                );

                focusables[0]?.focus();

                return true;
              }

              if (ref.current?.onKeyDown) {
                return ref.current.onKeyDown(props);
              }

              return false;
            },
            onExit() {
              onCancel();
            },
          };
        },
      }),
      EmojiPastePlugin,
      EmojiCopyPlugin,
      EmojiFallbackCleanupPlugin,
    ];
  },
  addInputRules() {
    return InputPlugin(this.type);
  },
  addKeyboardShortcuts() {
    return {
      Backspace: () =>
        this.editor.commands.command(({ tr, state }) => {
          const { empty, anchor } = state.selection;

          if (!empty) {
            return false;
          }

          let isBackspaceHandled = false;

          state.doc.nodesBetween(anchor - 1, anchor, (node, pos) => {
            if (node.type.name === EXTENSION_NAME) {
              tr.deleteRange(pos, pos + node.nodeSize);
              isBackspaceHandled = true;
              return false;
            }
          });

          return isBackspaceHandled;
        }),
    };
  },
});

export { TwemojiExtension };
